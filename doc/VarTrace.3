'\"
'\" Copyright (c) 1998 Sun Microsystems, Inc.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id$
'\" 
.so man.macros
.TH VarTrace 3 1.0 Jacl "Jacl Library Procedures"
.BS
.SH INTERFACE
tcl.lang.VarTrace -- Interface for montoring the access on Tcl variables.

.SH METHODS
.sp
abstract void \fBtraceProc\fR(Interp \fIinterp\fR, String \fIname1\fR,
String \fIname2\fR, int \fIflags\fR)

.SH ARGUMENTS
.AS TclObject "table[]" .
.AP Interp interp
The interpreter accessing the variable.
.AP String name1
If the trace occurs on a scalar variable, \fIname1\fR contains the
name of the variable. If the trace occurs on an array element, or on a
whole array, \fIname1\fR contains the name of the array.
.AP String name2
If the trace occurs on an array element, \fIname2\fR contains the index of
the element. Otherwise \fIname2\fR is \fBnull\fR.
.AP int flags
Specifies when action has be applied on the variable when the trace
occurs. See below for details.
.BE

.SH DESCRIPTION

The \fBVarTrace\fR interface is used for montoring the access on Tcl
variables. A \fBVarTrace\fR instance can be registered for a Tcl
variable using \fIinterp\fR.\fBtraceVar\fR. The \fIflags\fR parameter to
\fIinterp\fR.\fBtraceVar\fR specifies which type(s) of access on the
variable should cause the \fBVarTrace\fR instance to be activated.

When the \fBVarTrace\fR instance is activated, its \fBtraceProc\fR
method is called. \fIname1\fR and \fIname2\fR give the name of the
traced variable in the normal two-part form. \fIflags\fR is an OR-ed
combination of bits providing several pieces of information. One of
the bits \fBTCL\fR.\fBTRACE_READS\fR, \fBTCL\fR.\fBTRACE_WRITES\fR, or
\fBTCL\fR.\fBTRACE_UNSETS\fR will be set in \fIflags\fR to indicate which
operation is being performed on the variable. The bit
\fBTCL\fR.\fBGLOBAL_ONLY\fR will be set whenever the variable being
accessed is a global one not accessible from the current level of procedure
call: \fBtraceProc\fR will need to pass this flag back to
variable-related procedures like \fIinterp\fR.\fBgetVar\fR if it attempts
to access the variable. The bit \fBTCL\fR.\fBTRACE_DESTROYED\fR will be set
in \fIflags\fR if the trace is about to be destroyed; this information
may be useful to \fBtraceProc\fR so that it can clean up its own
internal data structures (see the section \fBTCL\fR.\fBTRACE_DESTROYED\fR
below for more details). Lastly, the bit \fBTCL\fR.\fBINTERP_DESTROYED\fR
will be set if the entire interpreter is being destroyed. When this
bit is set, \fBtraceProc\fR must be especially careful in the things
it does (see the section \fBTCL\fR.\fBINTERP_DESTROYED\fR below).

.SH "ACCESSING VARIABLES DURING TRACES"

During read and write traces, \fBtraceProc\fR can read, write, or
unset the traced variable using \fIinterp\fR.\fBgetVar\fR,
\fIinterp\fR.\fBsetVar\fR, and other procedures.  While
\fBtraceProc\fR is executing, traces are temporarily disabled for the
variable, so that calls to \fIinterp\fR.\fBgetVar\fR and
\fIinterp\fR.\fBsetVar\fR will not cause \fBtraceProc\fR or other
trace procedures to be invoked again.  Disabling only occurs for the
variable whose trace procedure is active; accesses to other variables
will still be traced.  However, if a variable is unset during a read
or write trace then unset traces will be invoked.
 
During unset traces the variable has already been completely expunged.
It is possible for the trace procedure to read or write the variable,
but this will be a new version of the variable.  Traces are not
disabled during unset traces as they are for read and write traces,
but existing traces have been removed from the variable before any
trace procedures are invoked. If new traces are set by unset trace
pro- cedures, these traces will be invoked on accesses to the variable
by the trace procedures.
 
.SH ERROR RETURNS

If \fBtraceProc\fR throws a TclException, it signifies that an error
occurred, in which case no further traces are invoked for the access
and the traced access aborts with the message given by the
TclException. Trace procedures can use this facility to make variables
read-only, for example (but note that the value of the variable will
already have been modified before the trace procedure is called, so
the trace procedure will have to restore the correct value).
 
The TclException is used only during read and write tracing. During
unset traces, the TclException is ignored and all relevant trace
procedures will always be invoked.

.SH TCL.TRACE_DESTROYED FLAG

In an unset callback to \fBtraceProc\fR, the
\fBTCL\fR.\fBTRACE_DESTROYED\fR bit is set in \fIflags\fR if the trace
is being removed as part of the deletion. Traces on a variable are
always removed whenever the variable is deleted; the only time
\fBTCL\fR.\fBTRACE_DESTROYED\fR isn't set is for a whole-array trace
invoked when only a single element of an array is unset.
 
.SH TCL.INTERP_DESTROYED FLAG

When an interpreter is destroyed, unset traces are called for all of
its variables. The \fBTCL\fR.\fBINTERP_DESTROYED\fR bit will be set in the
\fIflags\fR argument passed to the trace procedures. Trace procedures
must be extremely careful in what they do if the
\fBTCL\fR.\fBINTERP_DESTROYED\fR bit is set. It is not safe for the
procedures to invoke any Tcl procedures on the interpreter, since its
state is partially deleted.  All that trace procedures should do under
these circumstances is to clean up and free their own internal data
structures.

.SH "EQUIVALENT C FUNCTIONS"
Tcl_TraceProc

.SH "SEE ALSO"
Interp, setVar, traceVar

.SH KEYWORDS
trace, variable
