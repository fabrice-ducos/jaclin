test_tjc_init

# Test series 9 checks inlined and
# optimized expr operations. These
# expr oprations are more easily
# inlined and should offer runtime
# execution speed improvements
# over the expr operations implemented
# as part of +inline-containers.
#
# This is enabled via the +inline-expr
# OPTIONS flag.

# Load jdk test data in case this has not already been done.
source [file join [tcltest::testsDirectory] jdkutils.tcl]
test_jdk_load_config

# Invoked after compileproc_init is invoked inside compileproc_compile.

proc test_compileproc_9_set_flags { proc_name } {
    global _compileproc
    global test_compileproc_9_inline_expr

    # Inline all containers but don't bother caching commands.
    set _compileproc(options,inline_containers) {all}

    # Use inlined variables.
    set _compileproc(options,cache_variables) 1

    # Use inlined commands
    set _compileproc(options,inline_commands) 1
    set _compileproc(options,inline_controls) 1

    # Skip constant incr.
    set _compileproc(options,skip_constant_increment) 1

    # Omit unused results
    set _compileproc(options,omit_results) 1

    # Enable inline expr optimizations if flag
    # is not set or is set to true.

    if {![info exists test_compileproc_9_inline_expr]} {
        set _compileproc(options,expr_inline_operators) 1
    } else {
        if {$test_compileproc_9_inline_expr} {
            set _compileproc(options,expr_inline_operators) 1
        }
        unset test_compileproc_9_inline_expr
    }
}

tcltest::test compileproc9-1.0 {expr eq/ne operators, no +inline-expr} {
    set script {
proc p {} {
    expr {$v1 eq $v2}
    expr {$v1 ne $v2}
}
}

    set test_compileproc_9_inline_expr 0
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 2, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {$v1 eq $v2}
            // Binary operator: $v1 eq $v2
            TclObject tmp0 = getVarScalar(interp, "v1", compiledLocals, 0);
            ExprValue tmp1 = TJC.exprGetValue(interp, tmp0);
            TclObject tmp2 = getVarScalar(interp, "v2", compiledLocals, 1);
            ExprValue tmp3 = TJC.exprGetValue(interp, tmp2);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_STREQ, tmp1, tmp3);
            TJC.exprReleaseValue(interp, tmp3);
            // End Binary operator: eq
            TJC.exprSetResult(interp, tmp1);
            TJC.exprReleaseValue(interp, tmp1);
        } // End Invoke: expr
        { // Invoke: expr {$v1 ne $v2}
            // Binary operator: $v1 ne $v2
            TclObject tmp4 = getVarScalar(interp, "v1", compiledLocals, 0);
            ExprValue tmp5 = TJC.exprGetValue(interp, tmp4);
            TclObject tmp6 = getVarScalar(interp, "v2", compiledLocals, 1);
            ExprValue tmp7 = TJC.exprGetValue(interp, tmp6);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_STRNEQ, tmp5, tmp7);
            TJC.exprReleaseValue(interp, tmp7);
            // End Binary operator: ne
            TJC.exprSetResult(interp, tmp5);
            TJC.exprReleaseValue(interp, tmp5);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    String[] compiledLocalsNames = {
        "v1",
        "v2"
    };
} // end class Test1
}}

tcltest::test compileproc9-1.1 {expr eq/ne operators, enable +inline-expr} {
    # This example will inline string compare operations
    # for the eq an ne operators. These operators are
    # commonly used with TclObject arguments, so the
    # compiler provides an inlined implementation for
    # the case where both operands are TclObjects.
    # This avoids parsing the objects and does not
    # call the exprBinaryOperator() method.

    set script {
proc p {} {
    expr {$v1 eq $v2}
    expr {$v1 ne $v2}
}
}

    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 2, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {$v1 eq $v2}
            // Binary operator: $v1 eq $v2
            TclObject tmp0 = getVarScalar(interp, "v1", compiledLocals, 0);
            String tmp1 = tmp0.toString();
            TclObject tmp2 = getVarScalar(interp, "v2", compiledLocals, 1);
            String tmp3 = tmp2.toString();
            boolean tmp4 = tmp1.equals(tmp3);
            ExprValue tmp5 = TJC.exprGetValue(interp, tmp4);
            // End Binary operator: eq
            TJC.exprSetResult(interp, tmp5);
            TJC.exprReleaseValue(interp, tmp5);
        } // End Invoke: expr
        { // Invoke: expr {$v1 ne $v2}
            // Binary operator: $v1 ne $v2
            TclObject tmp6 = getVarScalar(interp, "v1", compiledLocals, 0);
            String tmp7 = tmp6.toString();
            TclObject tmp8 = getVarScalar(interp, "v2", compiledLocals, 1);
            String tmp9 = tmp8.toString();
            boolean tmp10 = ! tmp7.equals(tmp9);
            ExprValue tmp11 = TJC.exprGetValue(interp, tmp10);
            // End Binary operator: ne
            TJC.exprSetResult(interp, tmp11);
            TJC.exprReleaseValue(interp, tmp11);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    String[] compiledLocalsNames = {
        "v1",
        "v2"
    };
} // end class Test1
}}

tcltest::test compileproc9-1.2 {expr eq/ne operators, enable +inline-expr} {
    # This example will string compare a TclObject to
    # an ExprValue. This need not create an ExprValue
    # for the left operand or invoke exprBinaryOperator().

    set script {
proc p {} {
    expr {$v eq 1}
    expr {$v ne 1}
    expr {1 eq $v}
    expr {1 ne $v}
}
}

    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 1, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {$v eq 1}
            // Binary operator: $v eq 1
            TclObject tmp0 = getVarScalar(interp, "v", compiledLocals, 0);
            String tmp1 = tmp0.toString();
            ExprValue tmp2 = TJC.exprGetValue(interp, 1, null);
            boolean tmp3 = tmp1.equals(tmp2.getStringValue());
            tmp2.setIntValue(tmp3);
            // End Binary operator: eq
            TJC.exprSetResult(interp, tmp2);
            TJC.exprReleaseValue(interp, tmp2);
        } // End Invoke: expr
        { // Invoke: expr {$v ne 1}
            // Binary operator: $v ne 1
            TclObject tmp4 = getVarScalar(interp, "v", compiledLocals, 0);
            String tmp5 = tmp4.toString();
            ExprValue tmp6 = TJC.exprGetValue(interp, 1, null);
            boolean tmp7 = ! tmp5.equals(tmp6.getStringValue());
            tmp6.setIntValue(tmp7);
            // End Binary operator: ne
            TJC.exprSetResult(interp, tmp6);
            TJC.exprReleaseValue(interp, tmp6);
        } // End Invoke: expr
        { // Invoke: expr {1 eq $v}
            // Binary operator: 1 eq $v
            ExprValue tmp8 = TJC.exprGetValue(interp, 1, null);
            TclObject tmp9 = getVarScalar(interp, "v", compiledLocals, 0);
            boolean tmp10 = tmp8.getStringValue().equals(tmp9.toString());
            tmp8.setIntValue(tmp10);
            // End Binary operator: eq
            TJC.exprSetResult(interp, tmp8);
            TJC.exprReleaseValue(interp, tmp8);
        } // End Invoke: expr
        { // Invoke: expr {1 ne $v}
            // Binary operator: 1 ne $v
            ExprValue tmp11 = TJC.exprGetValue(interp, 1, null);
            TclObject tmp12 = getVarScalar(interp, "v", compiledLocals, 0);
            boolean tmp13 = ! tmp11.getStringValue().equals(tmp12.toString());
            tmp11.setIntValue(tmp13);
            // End Binary operator: ne
            TJC.exprSetResult(interp, tmp11);
            TJC.exprReleaseValue(interp, tmp11);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    String[] compiledLocalsNames = {
        "v"
    };
} // end class Test1
}}

tcltest::test compileproc9-1.3 {expr eq/ne operators, enable +inline-expr} {
    # Compare a TclObject result from a command to an ExprValue.

    set script {
proc p {} {
    expr {[cmd] eq 1}
}
}

    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {[cmd] eq 1}
            // Binary operator: [...] eq 1
            { // Invoke: cmd
                TclObject[] objv0 = TJC.grabObjv(interp, 1);
                try {
                    // Arg 0 constant: cmd
                    objv0[0] = const0;
                    TJC.invoke(interp, null, objv0, 0);
                } finally {
                    TJC.releaseObjv(interp, objv0, 1);
                }
            } // End Invoke: cmd
            TclObject tmp1 = interp.getResult();
            String tmp2 = tmp1.toString();
            ExprValue tmp3 = TJC.exprGetValue(interp, 1, null);
            boolean tmp4 = tmp2.equals(tmp3.getStringValue());
            tmp3.setIntValue(tmp4);
            // End Binary operator: eq
            TJC.exprSetResult(interp, tmp3);
            TJC.exprReleaseValue(interp, tmp3);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("cmd");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc9-1.4 {expr eq/ne operators, enable +inline-expr} {
    # This example shows the same variable getting queried twice.
    # The logic must query and save the String value of the left
    # operand before getting the String value of the right operand
    # because of tricky var trace edge cases.
    set script {
proc p {} {
    expr {$v eq $v}
}
}

    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 1, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {$v eq $v}
            // Binary operator: $v eq $v
            TclObject tmp0 = getVarScalar(interp, "v", compiledLocals, 0);
            String tmp1 = tmp0.toString();
            TclObject tmp2 = getVarScalar(interp, "v", compiledLocals, 0);
            String tmp3 = tmp2.toString();
            boolean tmp4 = tmp1.equals(tmp3);
            ExprValue tmp5 = TJC.exprGetValue(interp, tmp4);
            // End Binary operator: eq
            TJC.exprSetResult(interp, tmp5);
            TJC.exprReleaseValue(interp, tmp5);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    String[] compiledLocalsNames = {
        "v"
    };
} // end class Test1
}}

tcltest::test compileproc9-1.5 {expr eq/ne operators, enable +inline-expr} {
    # When both operands are type ExprValue, then
    # the exprBinaryOperator() method is invoked.

    set script {
proc p {} {
    expr {255 eq -0xFF}
    expr {(1 + 0) ne 1}
}
}

    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {255 eq -0xFF}
            // Binary operator: 255 eq ()
            ExprValue tmp0 = TJC.exprGetValue(interp, 255, null);
            // Unary operator: - 255
            ExprValue tmp1 = TJC.exprGetValue(interp, -255, null);
            // End Unary operator: -
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_STREQ, tmp0, tmp1);
            TJC.exprReleaseValue(interp, tmp1);
            // End Binary operator: eq
            TJC.exprSetResult(interp, tmp0);
            TJC.exprReleaseValue(interp, tmp0);
        } // End Invoke: expr
        { // Invoke: expr {(1 + 0) ne 1}
            // Binary operator: () ne 1
            // Binary operator: 1 + 0
            ExprValue tmp2 = TJC.exprGetValue(interp, 1, null);
            ExprValue tmp3 = TJC.exprGetValue(interp, 0, null);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_PLUS, tmp2, tmp3);
            TJC.exprReleaseValue(interp, tmp3);
            // End Binary operator: +
            ExprValue tmp4 = TJC.exprGetValue(interp, 1, null);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_STRNEQ, tmp2, tmp4);
            TJC.exprReleaseValue(interp, tmp4);
            // End Binary operator: ne
            TJC.exprSetResult(interp, tmp2);
            TJC.exprReleaseValue(interp, tmp2);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc9-1.6 {expr eq/ne operators, enable +inline-expr} {

    set script {
proc p {} {
    expr {$v eq int($v)}
}
}

    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 1, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {$v eq int($v)}
            // Binary operator: $v eq math()
            TclObject tmp0 = getVarScalar(interp, "v", compiledLocals, 0);
            String tmp1 = tmp0.toString();
            // Math function: int $v
            TclObject tmp2 = getVarScalar(interp, "v", compiledLocals, 0);
            ExprValue tmp3 = TJC.exprGetValue(interp, tmp2);
            TJC.exprIntMathFunction(interp, tmp3);
            // End Math function: int
            boolean tmp4 = tmp1.equals(tmp3.getStringValue());
            tmp3.setIntValue(tmp4);
            // End Binary operator: eq
            TJC.exprSetResult(interp, tmp3);
            TJC.exprReleaseValue(interp, tmp3);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    String[] compiledLocalsNames = {
        "v"
    };
} // end class Test1
}}

tcltest::test compileproc9-1.7 {expr ==/!= operators, no +inline-expr} {
    set script {
proc p {} {
    expr {$v1 == $v2}
    expr {$v1 != $v2}
}
}

    set test_compileproc_9_inline_expr 0
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 2, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {$v1 == $v2}
            // Binary operator: $v1 == $v2
            TclObject tmp0 = getVarScalar(interp, "v1", compiledLocals, 0);
            ExprValue tmp1 = TJC.exprGetValue(interp, tmp0);
            TclObject tmp2 = getVarScalar(interp, "v2", compiledLocals, 1);
            ExprValue tmp3 = TJC.exprGetValue(interp, tmp2);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_EQUAL, tmp1, tmp3);
            TJC.exprReleaseValue(interp, tmp3);
            // End Binary operator: ==
            TJC.exprSetResult(interp, tmp1);
            TJC.exprReleaseValue(interp, tmp1);
        } // End Invoke: expr
        { // Invoke: expr {$v1 != $v2}
            // Binary operator: $v1 != $v2
            TclObject tmp4 = getVarScalar(interp, "v1", compiledLocals, 0);
            ExprValue tmp5 = TJC.exprGetValue(interp, tmp4);
            TclObject tmp6 = getVarScalar(interp, "v2", compiledLocals, 1);
            ExprValue tmp7 = TJC.exprGetValue(interp, tmp6);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_NEQ, tmp5, tmp7);
            TJC.exprReleaseValue(interp, tmp7);
            // End Binary operator: !=
            TJC.exprSetResult(interp, tmp5);
            TJC.exprReleaseValue(interp, tmp5);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    String[] compiledLocalsNames = {
        "v1",
        "v2"
    };
} // end class Test1
}}

tcltest::test compileproc9-1.8 {expr ==/!= operators, enable +inline-expr} {
    # Only the eq and ne operators are currently inlined
    # by +inline-expr.
    set script {
proc p {} {
    expr {$v1 == $v2}
    expr {$v1 != $v2}
}
}

    set test_compileproc_9_inline_expr 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_9_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 2, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {$v1 == $v2}
            // Binary operator: $v1 == $v2
            TclObject tmp0 = getVarScalar(interp, "v1", compiledLocals, 0);
            ExprValue tmp1 = TJC.exprGetValue(interp, tmp0);
            TclObject tmp2 = getVarScalar(interp, "v2", compiledLocals, 1);
            ExprValue tmp3 = TJC.exprGetValue(interp, tmp2);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_EQUAL, tmp1, tmp3);
            TJC.exprReleaseValue(interp, tmp3);
            // End Binary operator: ==
            TJC.exprSetResult(interp, tmp1);
            TJC.exprReleaseValue(interp, tmp1);
        } // End Invoke: expr
        { // Invoke: expr {$v1 != $v2}
            // Binary operator: $v1 != $v2
            TclObject tmp4 = getVarScalar(interp, "v1", compiledLocals, 0);
            ExprValue tmp5 = TJC.exprGetValue(interp, tmp4);
            TclObject tmp6 = getVarScalar(interp, "v2", compiledLocals, 1);
            ExprValue tmp7 = TJC.exprGetValue(interp, tmp6);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_NEQ, tmp5, tmp7);
            TJC.exprReleaseValue(interp, tmp7);
            // End Binary operator: !=
            TJC.exprSetResult(interp, tmp5);
            TJC.exprReleaseValue(interp, tmp5);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    String[] compiledLocalsNames = {
        "v1",
        "v2"
    };
} // end class Test1
}}


# Cleanup
jdk_tool_cleanup
tcltest::cleanupTests

